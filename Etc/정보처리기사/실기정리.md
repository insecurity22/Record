### ＊소프트웨어

#### 1. 디자인 패턴
: 모듈 간의 관계 및 인터페이스를 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제를 의미한다.
- GoF 디자인 패턴
![image](https://user-images.githubusercontent.com/24931069/194764409-009be4fb-fc3a-4b34-8464-51697bbc77ae.png)
참고) https://gmlwjd9405.github.io/2018/07/06/design-pattern.html
```
생성 패턴 : 인스턴트를 만드는 절차를 추상화하는 패턴
구조 패턴 : 클래스나 객체를 조합해 더 큰 구조를 만드는 패턴
행위 패턴 : 클래스나 객체들이 서로 상호작용하는 방법이나 책임 분배 방법을 정의하는 패턴으로, Interpreter, Observer, Command 등이 그 예에 해당한다.
```

- Factory Method
  - 객체 생성을 서브 클래스에서 처리하도록 분리하여 캡슐화한 패턴으로, 상위 클래스에서 인터페이스만 정의하고 실제 생성은 서브 클래스가 담당한다. 다른 이름으로 가상 생성자(Virtual Constructor) 패턴이라고도 불린다.
  - 아래 사이트 설명 짱,, 바로 이해,,,,
  ex) https://sup2is.github.io/2020/06/23/factory-method-pattern.html

#### 2. 객체지향 분석
- 사용자의 요구사항을 분석하여 요구된 문제와 관련된 모든 클래스(객체), 이와 연관된 속성과 연산, 그들간의 관계 등을 정의하여 모델링하는 작업이다.
- 데이터 모델링 방법론
  - Rumbaugh(럼바우) 방법
    - 가장 일반적으로 사용되는 방법으로 분석 활동을 **객체 모델, 동적 모델, 기능 모델**로 나누어 수행하는 방법
    	: 소프트웨어 구성 요소를 그래픽 표기법을 이용하여 모델링, 객체 모델링 기법이라고도 함
    ```
      Object or Information(객체): 시스템에서 요구되는 객체를 찾아내어 속성과 연산 식별 및 객체들 간의 관계를 규정하여 표시하는 모델링
      ex) ER 다이어그램(ERD)
      Dynamic(동적): 시간의 흐름에 따른 객체들 간의 제어 흐름, 상호 작용, 동작 순서 등의 동적인 행위를 표현하는 모델링
      ex) 상태 변화도(STD), 사건 추적도
      Function(기능): 다수의 프로세스들 간의 자료 흐름을 중심으로 처리 과정을 표현한 모델링
      ex) 자료 흐름도(DFD)
    ```
  - Booch(부치) 방법
    - Use Case를 강조하여 사용하는 분석 방법
  - Coad와 Yourdon 방법
    - E-R 다이어그램을 사용하여 개체의 활동들을 데이터 모델링하는데 초점을 둔 기법
  - Wirfs-Brock 방법
    - 분석과 설계 간의 구분이 없고, 고객 명세서를 평가해서 설계작업까지 연속적으로 수행하는 기법

#### 3. 요구사항 정의 및 확인
- 요구사항 내용의 종류에 따라 **기능적 요구사항과 비기능적 요구사항**으로 나눌 수 있다.
  - 기능 요구사항
    - 시스템이 무엇을 하는지, 어떤 기능을 하는지 등 사용자가 시스템을 통해 제공받기를 원하는 기능이나 시스템이 반드시 수행해야하는 기능을 의미한다.
  - 비기능 요구사항
    - 품질이나 제약사항과 관련된 요구사항으로, 시스템의 장비 구성, 성능, 인터페이스, 테스트, 보안 등의 요구사항을 말한다.
- 요구사항이 무엇인지 이해함으로써 요구사항에 적합한 소프트웨어를 만들 수 있다.

#### 4. 모듈 연계 방법
- 모듈 연계는 내부 모듈과 외부 모듈 또는 내부 모듈 간의 데이터의 교환을 위해 관계를 설정하는 것으로 대표적인 모듈 연계 방법에는 EAI와 ESB 방식이 있다.
- EAI(Enterprise Application Integeration)
  - 기업 내 각종 애플리케이션 및 플랫폼 간의 정보 전달, 연계, 통합 등 상호 연동이 가능하게 해주는 솔루션으로 다양한 방식으로 구축이 가능
  - 유형
    - Point-to-Point
    - Hub&Spoke
    - Message Bus
    - Hybrid

![image](https://user-images.githubusercontent.com/24931069/196003036-633c9493-ad48-40c1-9dec-8eb91cb8e06f.png)

- ESB(Enterprise Service Bus)
참고) https://lipcoder.tistory.com/315

#### 5. 리팩토링(Refactoring) 목적
- 프로그램을 쉽게 이해하고 수정하여 빠르게 개발할 수 있도록 하기 위함이다.
- 결과의 변경 없이 코드의 구조를 재조정함
- 주로 가독성을 높이고 유지보수를 편하게 한다.

#### 6. 소프트웨어 개발에서의 작업, 형상관리(SCM)
```
특정 항목의 변화에 대해 관리하면서 시스템의 통합과 일치를 보장하는 것이다.
소프트웨어 개발이라는건 끊임없는 수정을 필요로 한다.
사용자의 요구사항 추가, 버그 수정 등
지속적으로 생기는 변경사항들을 체계적으로 정리 및 관리를 해야한다.

즉 형상 관리는 개발 중 발생하는 모든 산출물들이 변경됨으로써
점차 변해가는 소프트웨어 형상을 체계적으로 관리하고 유지하는 기법이다.
```

1) 형상 식별
2) 형상 통제
- 식별된 형상 항목에 대한 변경 요구를 검토하여 현재의 기준선이 잘 반영될 수 있도록 조정하는 작업이다.
```
소프트웨어 개발에서 가장 어려운 부분 중의 하나가 사용자 요구 사항의 잦은 변경을 꼽을 수 있다. 
사용자의 요구 사항은 더는 없다고 확정하고 도장을 찍는 순간에도 일어날 만큼 계속 발생한다. 

이처럼 변경에 대한 요구를 무조건 다 수용하다가는 
소프트웨어 개발이 순조롭게 진행될 수 없을 것이다. 
따라서 변경을 위해서는 변경하고자 하는 요구를 
정해진 양식에 맞추어 작성하고 

형상통제위원회(CCB: Configuration Control Board)에서는 
그 변경 요청을 수용할 것인지, 거절할 것인지 결정하여 결과를 통보해준다. 

이처럼 형상 목록의 변경 요구를 검토 및 승인하여 
현재의 소프트웨어 기준선에 반영될 수 있도록 통제하는 
일련의 과정을 형상 통제(configuration control)라 한다.

형상 통제는 변경 요청, 변경 심사, 변경 실시, 변경 확인 등으로 세분화할 수 있다
```
3) 형상 감사
5) 형상 기록

참고) https://velog.io/@beom2day/%ED%98%95%EC%83%81%EA%B4%80%EB%A6%ACconfiguration-management

#### 7. 사용자 인터페이스(UI:User Interface)
- 사용자와 시스템 간의 상호작용이 원활하게 이뤄지도록 도와주는 장치나 소프트웨어

#### 7-1. 사용자 인터페이스의 기본 원칙
- 직관성 : 누구나 쉽게 이해하고 사용할 수 있어야 한다.
- 유효성 : 사용자의 목적을 정확하게 달성하여야 한다.
- 학습성 : 누구나 쉽게 배우고 익힐 수 있어야 한다.
- 유연성 : 사용자의 요구사항을 최대한 수용하며, 오류를 최소화하여야한다.

------------

#### 2. 파일의 구조
- 파일의 구조는 파일을 구성하는 레코드들이 보조기억장치에 편성되는 방식을 의미하는 것으로 크게 **순차, 색인(Index), 해싱**으로 구성된다.
- 색인 파일 구조는 <값,주소> 쌍으로 구성되는 데이터 구조를 활용하여 데이터에 접근하는 방식으로, 자기 디스크에서 주로 활용된다.

#### 3. UML(Unified Modeling Language)
- 소프트웨어 시스템을 개발하는 과정에서 산출물의 명세화, 시각화, 문서화할 때 사용하는 모델링 언어로써 하나의 시스템을 표현하기 위한 표준적인 방법을 제공하기 위해서 만들어졌다.
- 통합 모델링 언어를 사용하여 시스템 상호작용, 업무흐름, 시스템 구조, 컴포넌스 관계 등을 그린 도면입니다.
- UML 다이어그램을 사용하는 이유는 프로그래밍을 단순화시켜 표현하여 의사소통하기도 좋고
- 대규모 프로젝트 구조의 로드맵을 만들거나 개발을 위한 시스템 구축에 기본을 마련합니다.
##### 1) UML Diagram의 종류
##### - 구조 다이어그램
- 클래스(Class) 다이어그램 : 시스템의 구조적인 모습을 그림
  - UML 다이어그램 중 객체(Object)들을 **클래스**로 추상화하여 표현하는 다이어그램으로 대표적인 구조적 다이어그램이다.
- 객체(Object) 다이어그램
- 패키지(Package) 다이어그램
	![image](https://user-images.githubusercontent.com/24931069/195992667-d29c6be9-1896-4585-8936-9856828fa39e.png)
- 컴포넌트(Component) 다이어그램 : 소프트웨어 구조를 그림
- 배치(Deployment) 다이어그램 : 기업 환경의 구성과 컴포넌트들 간의 관계를 그림

##### - 행위 다이어그램
- 쓰임새(Use Case) 다이어그램 : 사용자 관점에서 바라본 시스템을 표현한 다이어그램
- 활동(Activity) 다이어그램 : 업무의 흐름을 모델링하거나 객체의 생명주기를 표현함
- 상태(State) 다이어그램 : 하나의 객체가 다른 객체와의 상호 작용에 따라 어떻게 변화하는지 표현하는 다이어그램
- 순서(Sequence) 다이어그램 : 객체 간의 메시지 전달을 시간적 흐름에서 분석함
- 통신(Communication=Callaboration=Interaction) 다이어그램 : 객체와 객체가 주고받는 메시지 중심의 작성
참고) https://m.blog.naver.com/icbanq/221781238065
참고) https://seulhee030.tistory.com/56
참고) https://m.blog.naver.com/msoffice7/221740368928

##### 2) 관계
- 사물과 사물 사이의 연관성을 표현
![image](https://user-images.githubusercontent.com/24931069/194765804-a1423049-343f-4942-935c-84515db16bfd.png)
참고) https://www.nextree.co.kr/p6753/

#### 4. 인터페이스
UI : 사용자가 시스템이나 서비스를 이용하면서 느끼고 생각하게 되는 총체적인 감정 및 경험
UX : 사용자와 시스템 간의 상호작용이 원활하게 이뤄지도록 도와주는 장치나 

------------

#### ＊애플리케이션 테스트
통합 테스트 : 단위 테스트가 끝난 모듈을 통합하는 과정에서 발생하는 오류 및 결함을 찾는 테스트 기법으로 상향식 통합 테스트와 하향식 통합 테스트가 있다.
- 상향식 통합 테스트 : 소프트웨어의 **하위 모듈**에서 **상위 모듈 방향**으로 통합하면서 테스트하는 기법
  - 하나의 주요 제어 모듈과 관련된 종속 모듈의 그룹인 **클러스터(Cluster)**가 필요하다.
  - 데이터의 입,출력을 확인하기 위해 더미 모듈인 **드라이버(Driver)**를 생성한다.
  	- 미완성이거나 문제가 있는 상위 모듈을 대체할 수 있는 테스트 드라이버
- 하향식 통합 테스트 : 소프트웨어의 **상위 모듈**에서 **하위 모듈 방향**으로 통합하면서 테스트하는 기법
  - **스텁(Stub)**
  	- 미완성이거나 문제가 있는 하위 모듈을 대체할 수 있는 테스트 스텁
- 혼합식 통합 테스트 : 하위 수준에서는 상향식 통합, 상위 수준에서는 하향식 통합을 사용해 최적의 테스트를 지원하는 방식

##### 1) 화이트박스 테스트
- 원시 코드의 논리적인 모든 경로를 테스트하여 테스트 케이스를 설계하는 방법 = 소스코드의 모든 조건문이 1번 이상 수행되도록 테스트 케이스를 설계하는 방법
- 테스트 과정의 초기에 적용
- 모듈 안의 작동을 직접 관찰
##### - 종류
- 기초 경로 검사
- 조건 검사
- 루프 검사
- 데이터 흐름 검사
##### - 테스트 검증 기준
- 문장 검증 기준 : **모든 구문이 한 번 이상 수행**되도록 테스트 케이스 설계
- 분기 검증 기준 : **모든 조건문이 한 번 이상 수행**되도록 테스트 케이스 설계
- 조건 검증 기준 : **모든 조건문에 대해 조건이 True인 경우와 False인 경우가 한 번 이상 수행**되도록 테스트 케이스 설계
- 분기/조건 기준 : **모든 조건문과 각 조건문에 포함된 개별 조건식의 결과가 True인 경우와 False인 경우가 한 번 이상 수행**되도록 테스트 케이스 설계
```
// 헷갈리는 문제...
1. 최소 한번은 모든 문장이 수행되도록 구성하는 검증 기준 = 구문(문장) 검증 기준
2. "조건식"이 참(True)/거짓(False)일 때 수행되도록 구성하는 검증 기준 = 결정(분기) 검증 기준
3. 2번과 달리 조건식에 상관없이 "개별 조건"이 참(True)/거짓(False)일 때 수행되도록 구성하는 검증 기준 = 조건 검증 기준
```

##### 2) 블랙박스 테스트
- 각 기능이 완전히 작동되는 것을 입증하는 테스트
- 기능 테스트라고도 함
- 요구사항 명세를 보면서 테스트하는 것
- 소프트웨어 인터페이스에서 실시되는 테스트
##### - 종류
- **동치 분할 검사(Equivalence Partitioning Testing)**
	- 입력 자료에 초점을 맞춰 테스트 케이스를 만들고 검사하는 방법으로 프로그램의 입력 조건에 타당한 입력 자료와 타당하지 않은 입력 자료의 개수를 균등하게 하여 테스트 케이스를 정하고, 해당 입력 자료에 맞는 결과가 출력되는지 확인하는 테스트 
	- 입력 조건이 유효한 경우와 그렇지 않은 경우의 입력 자료의 개수를 균등하게 정하는 검사 기법
	- 입력 값을 넣고 예상되는 출력값이 나오는지 실제 값과 비교하는 명세 기반 
- **경계값 분석(Boundary Value Analysis)**
  - 입력 조건의 중간값보다 경계값에서 오류가 발생될 확률이 높다는 점을 이용한 검사 기법
```
0 <= x <= 10과 같은 조건이 있을 때
경계값 분석 : -1, 0, 10, 11을 입력 값으로
동치 분할 검사 : 0이상 10이하의 수 n개와 0미만 10초과의 수 n개를 입력 값으로 정한다.
```
- 원인-효과 그래프 검사(**Cause-Effect Graphing Testing**)
  - 그래프를 활용하여 입력 데이터 간의 관계와 출력에 영향을 미치는 상황을 체계적으로 분석한 다음 효용성이 높은 테스트 케이스를 선정하여 검사하는 기법
  - 오류 예측 검사(Error Guessing)
  - 비교 검사(Comparison Testing)

##### 3) 단위 테스트
- 코딩 직후 소프트웨어 설계의 최소 단위인 모듈이나 컴포넌트에 초점을 맞춰 수행하는 테스트로, 모듈 테스트라고도 불린다.
- 사용자의 요구사항을 기반으로 한 기능성 테스트를 최우선으로 인터페이스, 외부적 I/O, 자료구조, 독립적 기초 경로, 오류 처리 경로, 경계 조건 등을 검사한다.

##### 4) 통합 테스트
- 모듈들을 결합하여 하나의 시스템으로 완성시키는 과정에서의 테스트를 의미하며, 모듈 간 또는 컴포넌트 간의 인터페이스가 정상적으로 실행되는지 검사한다.

#### 테스트 오라클(Test Oracle)
- 결과를 판단하기 위해 테스트 케이스에 대한 예상 결과를 계산하거나 확인하는 기법 및 활동
- 특징 : 제한된 검증, 수학적 기법, 자동화 기능

| | |
|---|---|
|참(True) 오라클|발생된 모든 오류를 검출할 수 있음|
|샘플링(Sampling) 오라클|특정한 테스트 케이스의 입력 값에 대해서만 결과 제공|
|추정(Heuristic) 오라클|샘플링 오라클을 개선한 오라클|
|일관성 검사(Consistent) 오라클|테스트 케이스의 수행 전과 후의 결과 값이 동일한지를 확인하는 오라클|

참고) https://m.blog.naver.com/ehtm/221920748659

------------

### ＊데이터베이스
#### 1. 데이터베이스의 상태 변화를 일으키는 트랜잭션(Transaction)의 특성
- 원자성(Atomicity)
   - 트랜잭션과 관련된 작업들이 모두 정상적으로 수행되거나 아예 하나도 실행되지 않아야한다는 All-or-Nothing 방식을 의미
   - **OR 트랜잭션의 연산은 데이터베이스에 모두 반영되도록 완료(Commit)되든지 아니면 전혀 반영되지 않도록 복구(Rollback)되어야한다는 특성을 의미**
 - 일관성(Consistency)
   - 트랜잭션이 성공적으로 실행되고 난 이후로 데이터베이스가 일관적으로 상태를 유지하는 것을 의미
 - 격리성(Isolation)
   - 하나의 트랜잭션을 통해 SQL 연산이 실행되는 도중에 다른 트랜잭션 연산 작업이 끼어들지 못하게 보장하는 것
 - 지속성(Durability)
   - 트랜잭션이 성공적으로 수행되고 난 이후 시스템의 오류 등과 같은 어떠한 경우에도 데이터가 손실되지 않고 그 결과가 영원히 반영되어야 한다.
참고) https://iwuooh.com/entry/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98Database-Transaction%EC%9D%98-%EA%B0%9C%EB%85%90%EA%B3%BC-4%EA%B0%80%EC%A7%80-%ED%8A%B9%EC%84%B1?category=982116#:~:text=%EC%9D%B4%EB%A1%A0%EC%A0%81%EC%9C%BC%EB%A1%9C%20%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%20%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%80,(Durability)%EC%9D%84%20%EB%B3%B4%EC%9E%A5%ED%95%9C%EB%8B%A4.

#### 2. 데이터베이스 스키마(Schema)
- 데이터베이스의 구조와 제약 조건에 관한 전반적인 명세를 기술한 것이다.

#### 3. 데이터베이스 설계
- **물리적 설계** : 논리적 구조로 표현된 데이터를 디스크 등의 저장장치에 저장할 수 있는 데이터로 변환하는 과정으로, 파일의 저장 구조 및 액세스 경로를 결정하며, **테이블 정의서 및 명세서가 산출된다.**
- **개념적 설계** : 현실 세계에 대한 인식을 **추상적 개념으로 표현하는 과정으로, 개념 스키마 모델링과 트랜잭션 모델링을 수행하며, 요구 조건 명세를 E-R 다이어그램으로 작성**한다.
- **논리적 설계** : 현실의 자료를 특정 DBMS가 지원하는 자료구조로 변환하는 과정으로, **트랜잭션의 인터페이스를 설계하고, 정규화를 통해 스키마를 평가 및 정제**한다.

#### 4. 데이터 모델의 구성 요소 ★★★★★
1) **구조(Structure)**
- 논리적으로 표현된 개체들 간의 관계를 표시함

2) **연산(Operation)**
- 데이터베이스에 저장된 실제 데이터를 처리하는 방법을 표시함
 
3) **제약조건(Constraint)**
- 데이터베이스에 저장될 수 있는 실제 데이터의 논리적인 제약 조건을 표시함

```
1. 데이터베이스에 저장된 실제 데이터를 처리하는 작업에 대한 명세로서 데이터베이스를 조작하는 기본 도구에 해당한다. : 연산
2. 논리적으로 표현된 객체 타입들 간의 관계로서 데이터의 구성 및 정적 성질을 표현한다. : 구조
3. 데이터베이스에 저장될 수 있는 실제 데이터의 논리적인 제약 조건을 의미한다. : 제약조건
```

#### 4-1) 결합도(Coupling)와 응집도(Cohesion)
- 결합도
  - 모듈 내부가 아닌 외부의 모듈과 연관도 또는 모듈 간의 상호의존성을 나타내는 정도
  - 소프트웨어 구조에서 모듈 간의 관련성을 측정하는 척도
  - 특징
    - 모듈 연관성 없음
    - 인터페이스 의존성
    - 복잡성 감소
    - 파급효과 최소화
  - 유형(순서대로 결합도가 낮아진다)
    - 내용 결합도(Content Coupling) : 모듈 간의 인터페이스로 데이터, **지역 변수 등을 직접 참조하거나 수정★★★★**할 때의 결합도
    - 공통 결합도(Common Coupling) : 모듈 간의 인터페이스로 파라미터가 아닌 모듈 밖에 선언된 **전역 변수를 사용하여 전역 변수를 갱신하는 방식으로 상호작용★★★★**하는 때의 결합도
    - 외부 결합도(External Coupling)
    - 제어 결합도(Control Coupling)
    - 스탬프 결합도(Stamp Coupling) : 모듈 간의 인터페이스로 **배열이나 레코드 등의 자료 구조가 전달★★★★**될 때의 결합도
    - 자료 결합도(Data Coupling)
- 응집도
  - 모듈의 독립성을 나타내는 개념으로, 모듈 내부 구성요소 간 연관 정도
  - 정보 은닉의 확장개념으로 하나의 모듈은 하나의 기능을 수행하는 것을 의미 
  - 특징
    - 유사기능 영역 구성
    - 단일 책임할당
    - 함수 간 상호협력
  - 유형(순서대로 응집도가 높아진다)
    - 우연적 응집도(Coincidental Cohesion) : 모듈 내부의 각 구성요소들이 연관이 없을 경우
    - 논리적 응집도(Logical Cohesion) : 실제와 달리 논리적으로만 같은 그룹으로 분류되는 처리 요소들이 한 모듈에서 처리되는 경우
    - 시간적 응집도(Temporal Cohesion) : 연관된 기능이라기보단 특정 시간에 처리되어야 하는 활동들을 한 모듈에서 처리할 경우
    - 절차적 응집도(Procedural Cohesion) : 모듈 안의 구성요소들이 서로 다른 기능을 하지만 그 기능을 순차적으로 수행할 경우 = 내부의 요소들이 기능적으로 연관성은 없으나, 순차적으로 실행될 때의 응집도
    - 교환적 응집도(Communication Cohesion) : 서로 다른 기능을 수행하지만 동일한 입력과 출력을 사용할 때의 응집도
    - 순차적 응집도(Sequential Cohesion) : 모듈 내의 한 활동으로부터 나온 출력값을 모듈 내의 다른 활동이 사용할 경우
    - 기능적 응집도(Functional Cohesion) : 모듈 내부의 모든 기능이 단일한 목적을 위해 수행되는 경우 = 하나의 기능에 밀접하게 관련되어 있거나 연관되어 있을 때의 응집도
참고) https://itwiki.kr/w/응집도
https://computer-science-student.tistory.com/140

#### 5. 트랜잭션
- 데이터베이스 시스템에서 병행 제어 및 회복 작업 시 처리되는 작업의 논리적인 단위로 사용자가 시스템에 대한 서비스 요구 시 시스템이 응답하기 위한 상태 변환 과정의 작업 단위이다.
- 작업의 완전성을 보장해주는 것이다.

1) 트랜잭션의 성질
- 원자성
	- 하나라도 오류가 나면 전체 과정이 취소되어야 한다.
- 일관성
	- 트랜잭션 실행을 성공적으로 완료하면 언제나 일관성있는 데이터베이스 상태로 유지시키는 것을 의미한다.
- 독립성
	- 트랜잭션 수행 시, 다른 트랜잭션의 연산 작업이 끼어들지 못하도록 보장하는 것을 의미한다.
- 명속성, 지속성
	- 성공적으로 수행된 트랜잭션은 영구적으로 반영되어야 함을 의미한다.
	- 모든 트랜잭션은 로그로 남고 시스템 장애 발생 전 상태로 되돌리기가 가능하다.
	- 로그에 모든 것이 저장된 후에만 반영(commit) 상태로 간주될 수 있다.
참고) https://velog.io/@leki305/Database-트랜잭션이란

#### 6. 데이터베이스 이상
- 종류 3가지
	- 삽입 이상(Insertion Anomaly)
	- 삭제 이상(Deletion Anomaly)
	- 갱신 이상(Update Anomaly)

#### 7. 릴레이션 특징 및 용어
![image](https://user-images.githubusercontent.com/24931069/194771321-194394c9-8a5a-4b36-b763-157774c2faa6.png)
```
레코드 또는 튜플(Tuple) : 릴레이션을 구성하는 각각의 행
속성 또는 애트리뷰트(Attribute) : 릴레이션을 구성하는 각각의 열
카디널리티(Cardinality) : 튜플의 수
차수 (Degree) : 애트리뷰트의 수
등등...
```
참고) https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=kookh1&logNo=120184872122

#### 8. 데이터 언어
##### 1) DML(Data Manipulation Language) : 데이터 조작어
```
SELECT, INSERT, UPDATE, DELETE
```
##### 2) DDL(Data Definition Language) : 데이터 정의어
```
CREATE, ALTER, DROP, RENAME, TRUNCATE
```
##### 3) DCL(Data Control Language) : 데이터 제어어
```
★GRANT : 데이터베이스 관리자가 데이터베이스 사용자에게 권한을 부여하는데 사용하는 명령어이다.
*ROLLBACK : 작업을 취소하고 이전 상태로 되돌리기 위한 명령어이다. 
REVOKE:
```
##### 4) TCL(Transaction Control Language) : 트랜잭션 제어어
```
COMMIT, ROLLBACK, SAVEPOINT
```
참고) https://brownbears.tistory.com/180


#### 9. SQL문
##### 1) DML
- 조회
```
SELECT
- GROUP BY : 테이블의 레코드를 grouping 하기 위해 사용된다.
1) 주로 aggregate function(COUNT, MAX, MIN, SUM, AVG)와 함께 쓰인다.
2) 1개 이상의 컬럼에 대해 grouping 할 수 있다.
3) SELECT 절에는 GROUP BY에 쓰인 컬럼만 사용 가능하다.
ex) 학생 테이블에서 학과별 튜플의 개수를 검색하시오
(GROUP BY 사용하여, 실행결과 속성 : 학과, 학과별튜플수)
SELECT 학과, COUNT(*) as 학과별튜플수 FROM 학생 GROUP BY 학과 // 학과를 기준으로 그룹을 지정한다.

- HAVING
1) HAVING 절에는 COUNT, SUM, AVG, MAX, MIN 등 집계함수를 사용하여 조건을 부여할 수 있다.
ex) SELECT 
	과목이름, MIN(점수) as 최소점수, MAX(점수) as 최대점수
	FROM 성적
	GROUP BY 과목이름
	HAVING AVG(점수) >= 90;
```
- 수정
```
ex) UPDATE 상품목록 SET 제조가 = 100000, 생산지 = 'Australia' WHERE 상품명 = 'DR-725F';
```
- 삭제
```
ex) 테이블의 모든 행 삭제
=> DELETE FROM 테이블
ex) DELETE FROM 테이블 WHERE 이름='민수'
```
- 삽입
```
INSERT INTO 테이블이름(필드이름1, 필드이름2, ...) VALUES(데이터값1, 데이터값2, ...)
```
- 조인
```
교차 조인(CROSS JOIN) :  왼쪽 테이블의 데이터 1개당 오른쪽 테이블 데이터를 처음부터 끝까지 하나씩 결합한다. 그리고 왼쪽의 데이터가 없어질 때까지 반복한다. 
참고) https://araikuma.tistory.com/726
```
- 조건
```
ex) WHERE NAME = 'LEE'
ex) WHERE 학년 IN(3,4); // 학년의 값이 3 또는 4인 자료만을 대상으로 한다.
```
- 정렬
```
오름차순:asc (1,2,3,4 ...)
내림차순:desc (4,3,2,1 ...)
```

##### 2) DDL
- 테이블 추가
```
ex) CREATE TABLE test_table
// 인덱스 생성
ex) CREATE INDEX idx_name ON student(name); // student 테이블의 name 속성을 idx_name이라는 이름의 인덱스를 생성한다.
CREATE INDEX 인덱스이름 ON 테이블이름(필드이름1, 필드이름2, ...)
```
- 새로운 컬럼 추가
```
ex) ALTER TABLE 학생 ADD 주소 VARCHAR(20);
```
- 테이블 삭제
```
ex) DROP TABLE table_name
```

##### 3) DCL
- 권한 삭제
```
REVOKE UPDATE ON 수강 FROM 김사랑 CASCADE
- CASCADE : 사용 권한이 취소된 보안 주체에게 사용 권한을 부여받거나 거부당한 다른 보안 주체의 사용 권한도 취소됨을 나타냅니다.
```

#### 10. 정규화
```
문제가 생길 수 있는 커다란 테이블을 문제가 없도록 작은 테이블로 나누는 것
하지만 나누는 정도에 따라 규칙(제약조건)이 있고 그 정도를 정규형이라고 부른다
정규형은 1NF, 2NF, 3NF, **BCNF**, 4NF, 5NF, 6NF가 있는데, 
차수가 높아질 수록 규칙(제약조건)이 까다로워진다.
그래서 일반적으로는 1~3NF(또는 ~BCNF)까지만 사용하고 
나머지 정규형은 학문적 용도(전공, 수업, 논문 등)로 사용된다.
```
1. 1NF(제 1정규형) : 테이블(릴레이션)에 각 **도**메인은 원자성(Atomicity)을 가진다.
  - 셀이 더 작게 나눌 수 없는 단일 값을 가진다.
2. 2NF(제 2정규형) : 1NF를 먼저 충족시켜야 진행 가능하고, 속성 값의 결정이 기본키(또는 복합키)의 전체를 참조해야한다.
  - 완전 함수 종속을 만족하도록 테이블을 분해
  - 여기서 완전 함수 종속이란 기본키의 **부**분 집합이 결정자가 되어선 안된다는 것을 의미 
3. 3NF(제 3정규형) : 3NF도 2NF를 충족시킨 상태에서 진행 가능하고, 3NF는 모든 속성이 기본키(또는 복합키)에 **이**행적 함수 종속이 되지 않아야한다.
  - 이행적 함수 종속이란 X->Y고 Y->Z면 X->Z가 되는 것을 말한다.
4. BCNF 정규화 : 제 3정규화를 진행한 테이블에 대해 모든 **결**정자가 후보키가 되도록 테이블을 분해하는 것이다.
5. 4NF(제 4정규형) : **다**치 종속 제거
6. 5NF(제 5정규형) : **조**인 종속성 이용
참고) https://chankim.tistory.com/9

#### 10-2. 반정규화
- 데이터베이스의 성능 향상을 위하여, 데이터 중복을 허용하고 조인을 줄이는 데이터베이스 성능 향상 방법이다.
- 반정규화는 조회(select) 속도를 향상시키지만, 데이터 모델의 유연성은 낮아진다.
- 시스템의 성능을 향상시키고 개발 및 운영의 편의성 등을 높이기 위해 정규화된 데이터 모델을 의도적으로 통합, 중복, 분리하여 정규화 원칙을 위배하는 행위
참고) https://sodayeong.tistory.com/106

#### 10-3. 정규화/반정규화 차이
```
정규화는 기본적으로 데이터 중복성을 제거해주기 때문에(쪼개주기 때문에) 
성능 자체는 향상되는 특징을 가지고 있습니다. 
하지만 그만큼 조인이 많이 발생하기 때문에 
그에 따른 성능저하가 나타나는 경우가 있을 수 있죠. 

한가지 테이블안에서 어차피 조인이 가능하다면 
굳이 정규화를 진행할 필요가 없겠죠.
혹은 정규화가 되어있더라 하더라도 성능을 고려하여 
반정규화를 진행하는 것이 더 효율적일 수 있기 때문에 반정규화를 하게 됩니다.

하지만 무분별한 반정규화는 데이터 무결성을 깨뜨리는 역할을 하게 된다고합니다.
즉 성능의 이슈와 데이터 무결성의 보존 사이에서 정규화와 반정규화를 고려하게 되는것이죠.

정규화 반정규화 차이 참고) https://okky.tistory.com/39
```

#### 11. 로킹(Locking)
- 데이터베이스의 병행제어 기법 중 하나
- 접근한 데이터에 대한 연산을 모두 마칠 때까지 추가적인 접근을 제한함으로써 상호 배타적으로 접근하여 작업을 수행하도록 하는 기법
- 상호배제와 접근제어 기능
- Lock을 걸어 그 Lock을 건 트랜잭션만이 Lock을 해제할 수 있다
- 하나의 트랜잭션이 사용하는 데이터베이스 내의 데이터를 다른 트랜잭션이 접근하지 못하게 Lock을 설정하여
  다른 트랜잭션이 접근하지 못하도록 한다. 실행 완료 후엔 Lock을 해제한다.
```
쉽게 설명)
한번에 한명만 사용할 수 있게 하는 단위를 "로킹 단위"라 하는데
ex) 어떤 프로젝트의 소스를 여러 사람이 동시에 작업할 경우,
    누군가가 특정 파일을 건들고 있을 때, 
    다른 사용자는 그 파일을 건들지 못하도록 하는 것이 로킹
    이 때 로킹 단위 = 파일이 된다.
ex) 어떤 사람이 어떤 폴더에 있는 파일을 작업하고 있을 때
    그 폴더에 아예 접근 못하게 하게 되면
    이 때 로킹 단위 = 폴더가 된다.
ex) 한명씩 차례로 작업할 수만 있고, 누군가가 작업 중이고
    아예 프로젝트에 접근 못하도록 한다면,
    이 때 로킹 단위 = 프로젝트가 된다.
```
```
이 때 단위별로 나누어진 하나하나를 '로크'라고 하는데
로킹 단위를 '파일'로 하자면, 
파일 하나하나가 '로크'가 되니 당연히 그 수가 많아질테고
로킹 단위를 '폴더'로 하자면 훨씬 줄어들테고
로킹 단위를 '프로젝트'로 하면 로크는 1개밖에 없게 된다.

따라서 데이터베이스 트랜젝션에서도 로킹 단위는 파일, 레코드, 필드와 같이 여러가지로 나누어질 수도 있고

로킹 단위가 크면(ex프로젝트) -> 로크의 수가 적어지고 -> 제어 기법이 간단해지고 -> 병행성이 감소한다.
로킹 단위가 작으면(ex파일) -> 로크의 수가 많아지고 -> 제어하기 까다로우며 -> 병행성이 증가한다.
```
참고) https://raisonde.tistory.com/entry/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EB%A1%9C%ED%82%B9Locking-%EA%B8%B0%EB%B2%95%EA%B3%BC-%EB%A1%9C%ED%82%B9-%EB%8B%A8%EC%9C%84

#### 관계대수
- 릴레이션(행과 열로 구성된 2차원의 테이블)을 처리하는 연산의 집합
- 관계대수 연산자
	- 일반집합 연산자 : union, intersect, difference, cartesian product
	- 순수 관계 연산자 : selection, projection, join, division

![image](https://user-images.githubusercontent.com/24931069/196002509-143967c9-34e3-4716-a566-8ad31355687c.png)
참고) https://medium.com/learn-from-data/4-%EA%B4%80%EA%B3%84%EB%8C%80%EC%88%98-49e08fc22b16

```
릴레이션 A, B가 있을 때 릴레이션 B의 조건에 맞는 것들만
릴레이션 A에서 분리하여 프로젝션을 하는 연산이다. = ÷
```


#### 13. 데이터베이스 회복 기법
- 트랜잭션들을 수행하는 도중 장애로 인해 손상된 데이터베이스를 손상되기 이전의 정상적인 상태로 복구시키는 작업
- 회복 기법
  - 로그 기반 회복 기법
    - 지연 갱신 회복 기법(Deferred Update)
    - 즉각 갱신 회복 기법(Immediate Update)
      - 트랜잭션이 데이터를 변경하면 트랜잭션이 부분 완료되기 전이라도 즉시 실제 DB에 그 내용을 반영하는 기법
      - 장애가 발생하여 회복 작업할 경우를 대비하여 갱신된 내용들을 로그에 보관시킨다.
      - 회복 작업을 수행할 경우 Redo와 Undo 모두 수행이 가능하다.
  - 검사점 회복 기법(Checkpoint Recovery)
  - 그림자 페이징 회복 기법(Shadow Paging Recovery)
  - 미디어 회복 기법(Media Recovery)
  - ARIES 회복 기법
    - REDO 중 Repeating history
    - UNDO 중 Logging
참고) https://itwiki.kr/w/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4_%ED%9A%8C%EB%B3%B5

------------

### ＊네트워크
#### OSI 7 Layer
- 다른 시스템 간의 원활한 통신을 위해 ISO(국제표준화기구)에서 제안한 통신 규약(Protocal)이다.
```
물리(Physical) 계층
데이터링크(Data-Link) 계층 : 물리적으로 연결된 두 개의 인접한 개방 시스템들 간에 신뢰성있고 효율적인 정보 전송을 할 수 있도록 연결 설정, 데이터 전송, 오류 제어 등의 기능을 수행한다.
네트워크(Network) 계층 : 개방 시스템들 간의 네트워크 연결을 관리하며, 경로 제어, 패킷 교환, 트래픽 제어 등의 기능을 수행한다.
전송(Transport) 계층
세션(Session) 계층 
표현(Presentation) 계층 : 서로 다른 데이터 표현 형태를 갖는 시스템의 상호 접속을 위해 필요한 계층으로, 코드 변환, 데이터 암호화, 데이터 압축, 구문 검색 등의 기능을 수행한다.
응용(Application) 계층
```

#### 패킷 교환 방식
- 패킷 교환 방식은 접속 방식에 따라서 데이터 그램 방식과 가상회선 방식으로 구분된다.
![image](https://user-images.githubusercontent.com/24931069/194769028-99e2dae3-1a3a-49fd-b89f-cd3fcdd5cdfb.png)
##### 1) 데이터그램
- **비연결형 통신에서 주로 사용하는 방식으로, 사전에 접속 절차를 수행하지 않고 헤더에 출발지에서 목적지까지의 경로 지정을 위한 충분한 정보를 붙여서 개별적으로 전달하는 방식**
- 데이터를 전송하기 전에 논리적 연결이 설정되지 않으며 패킷이 독립적으로 전송된다.
- 패킷을 수신한 라우터는 최적의 경로를 선택하여 패킷을 전송하는데 하나의 메시지에서 분할된 여러 패킷은 서로 다른 경로로 전송될 수 있다.(비연결 지향형)
- 송신 측에서 전송한 순서와 수신 측에 도착한 순서가 다를 수 있다.

##### 2) 가상회선(VC)
![image](https://user-images.githubusercontent.com/24931069/194769043-73ac16f0-b0ec-4698-a774-da4be15a74c1.png)
- **연결형 통신에서 주로 사용되는 방식으로, 출발지와 목적지의 전송 경로를 미리 연결하여 논리적으로 고정한 후 통신하는 방식**
- 데이터를 전송하기 전에 논리적 연결이 설정되는데, 이를 가상회선이라고 한다.(연결 지향형)
- 각 패킷에는 가상회선 식별 번호(VCI)가 포함되고, 모든 패킷을 전송하면 가상회선이 해제되고 패킷들은 전송된 순서대로 도착한다.
- 데이터 그램은 패킷마다 라우터가 경로를 선택하지만, 가상회선 방식은 경로를 설정할 때 한 번만 수행한다.
참고) [https://jineer.tistory.com/50](https://woovictory.github.io/2018/12/28/Network-Packet-Switching-Method/)

#### 프로토콜
- 심리학자 톰 마릴은 컴퓨터가 메시지를 전달하고, 메시지가 제대로 도착했는지 확인하며, 도착하지 않았을 경우 메시지를 재전송하는 일련의 방법을 '기술적 은어'를 뜻하는 프토토콜 용어로 정의하였다.

#### Ad-hoc Network
- 재난 및 군사 현장과 같이 별도의 고정된 유선망을 구축할 수 없는 장소에서 모바일 호스트만을 이용하여 구성한 네트워크이다.
- 망을 구성한 후 단기간 사용되는 경우나 유선망을 구성하기 어려운 경우에 적합하다.
- 멀티 홉 라우팅 기능을 지원한다.

#### IPC(Inter-Process Communication)
- 프로세스들 간의 의사소통하는 것을 IPC라고 한다.
- 프로세스가 통신 가능하다는 것은 서로 다른 프로세스가 데이터를 주고 받을 수 있다는 것이며, 동시에 접근 가능한 메모리, 즉, 프로세스들이 공유하는 메모리가 필요하다는 것이다.
- 따라서 컴퓨터 내부에서 보다 효율적으로 정보를 주고 받기 위한 통신의 일종이라고 생각하면 되고, 인터넷 통신을 IPC의 확장으로 이해할 수 있다.
- **모듈 간 통신 방식을 구현하기 위해 사용되는 대표적인 프로그래밍 인터페이스 집합으로, 복수의 프로세스를 수행하며 이뤄지는 프로세스 간 통신까지 구현이 가능하다. 대표적인 메소드에는 공유 메모리(Shared Memory), 소켓(Socket), 세마포어(Semaphores), 파이프와 네임드 파이프(Pipes&named Pipes), 메시지 큐잉(Message Queueing)이 있다.**
참고) https://dar0m.tistory.com/233

#### ICMP
- TCP/IP 기반의 인터넷 통신 서비스에서 인터넷 프로토콜(IP)과 조합하여 통신 중에 발생하는 오류의 처리와 전송 경로의 변경 등을 위한 제어 메시지를 취급하는 무연결 전송용 프로토콜로, OSI 기본 참조 모델의 네트워크 계층에 속한다.

#### OSPF(Open Shortest Path First)
- RIP의 단점을 해결하여 새로운 기능을 지원하는 인터넷 프로토콜이다.
- 인터넷 망에서 이용자가 최단 경로를 선정할 수 있도록 라우팅 정보에 노드 간의 거리 정보, 링크 상태 정보를 실시간으로 반영하여 최단 경로로 라우팅을 지원한다.
- 대규모 네트워크에서 많이 사용한다
- 최단 경로 탐색에 Dijkstra 알고리즘을 사용한다.
- 라우팅 정보에 변화가 생길 경우 변화된 정보만 네트워크 내의 모든 라우터에 알린다
- 링크 스테이트 라우팅 알고리즘을 사용하여 하나의 자율 시스템(AS)에서 동작하면서 내부 라우팅 프로토콜의 그룹에 도달한다.

#### NAT(Network address Translation)
- 우리말로 번역하면 '네트워크 주소 변환'이라는 의미의 영문 3글자 약자이다.
- 1개의 정식 IP 주소에 다량의 가상 사설 IP 주소를 할당 및 연결하는 방식이다.
- 1개의 IP 주소를 사용해서 외부에 접속할 수 있는 노드는 어느 시점에서 1개만으로 제한되는 문제가 있으나 이 때에는 IP 마스커레이드(Masquerade)를 이용하면 된다.
```
내부 망에서는 사설 IP 주소를 사용하여 통신을 하고
외부 망과의 통신 시에는 NAT을 거쳐 공인 IP 주소로 자동 변환됩니다.
참고) https://m.blog.naver.com/ssdyka/221376674886
```

#### ARP, RARP
- ARP : IP 주소를 이용하여 MAC 주소를 찾는다.
- RARP : 인터넷 환경에서의 호스트 상호 간 통신에서 연결된 네트워크 접속 장치의 물리적 주소인 MAC 주소를 이용하여 IP 주소를 찾는 인터넷 계층의 프로토콜로, 역순 주소 결정 프로토콜이라 불린다.

------------

### * 인터넷
#### IPv4
- 32비트의 주소를 가지며 8비트씩 4부분, 총 32비트로 구성되어 있다. IPv4는 네트워크 부분의 길이에 따라 A클래스에서 E클래스까지 총 5단계로 구성되어 있다.

#### IPv6
- 128비트의 주소를 가지며, 인증성, 기밀성, 데이터 무결성의 지원으로 보안 문제를 해결할 수 있고, 주소의 확장성, 융통성, 연동성이 뛰어나다.

------------

### ＊프로그래밍
#### 1. 연산
- True / False
```
true : 1
false : 0
```
- 비트 연산
```
& : 모두 1이면 1 반환
| : 하나라도 1이면 1반환
~ : 반전
^(XOR) : 서로 다르면 1 반환, **즉 다르면 1, 같으면 0**
<< : 지정한 수만큼 비트들을 전부 왼쪽으로 이동
>> : 부호를 유지하면서 지정한 수만큼 비트를 전부 오른쪽으로 이동
```

#### 2. Python
False, True

```
lol = [[1,2,3], [4,5], [6,7,8,9]]
print(lol[0])
print(lol[2][1])
for sub in lol:
  for item in sub:
    print(item, end=' ')
  print()
  
// [1,2,3]
// 7
// 1 2 3
// 4 5
// 6 7 8 9
```

#### 3. C
##### 0) 생성자란
- 객체 변수 생성에 사용되는 메소드로 객체 변수를 생성하면서 초기화를 수행한다.

##### 1) 구조체
- 구조체의 멤버를 지정할 때는 [변수명].[멤버이름]으로 지정하지만 포인터 변수를 이용해 구조체의 멤버를 지정할 때는 [변수명]->[멤버이름]으로 지정한다.
```
...

struct jsu {
  char nae[12];
  int os, db, hab, hhab;
};

int main() {
  struct jsu st[3] = { {"데이터1", 95, 88}, {"데이터2", 84, 91}, {"데이터3", 86, 75} };
  struct jsu *p;
  p = &st[0];
  (p+1)->hab = (p+1)->os + (p+2)->db;
  (p+1)->hhab = (p+1)->hab + p->os + p->db;
  printf("%d", (p+1)->hab + (p+1)->hhab);
}
// 501
```
```
        char nae[12]              int os   int db     int hab     int hhab
st[0]   |데|이|터|1|\0| | | | |    95        88
st[1]   |데|이|터|2|\0| | | | |    84        91
st[2]   |데|이|터|3|\0| | | | |    86        75
```

##### 2) 포인터
1.
```
...

int* array[3];
int a = 12, b = 24, c = 36;
array[0] = &a;
array[1] = &b;
array[2] = &c;

*array[1] : array[1]의 주소값이 가리키는 곳의 값 = 24
**array : array의 주소값이 가리키는 곳의 값 = 12
```
2.
```
...
struct insa {
  char name[10];
  int age;
} a[] = { "Kim", 28, "Lee", 38, "Park", 42, "Choi", 31 };
struct insa* p;
p = a;
p++; // p = p + 1, p의 값을 1 증가시킨다. 
// 주소에 1을 더하는 것은 다음 자료를 가리키라는 것을 의미하므로 p는 a[1]의 위치를 가리키게 된다.
// 즉 a->name은 Lee, a->age는 38
```
3. A -> 65
```
...

char* p = "KOREA"; 
// 문자열을 저장하는 경우 
// 문자열의 끝을 의미하는 널 문자('\0')가 추가로 저장되며 
// 출력 시 널 문자는 표시되지 않습니다.

printf("%s\n", p);
printf("%s\n", p+3); // p+3의 위치부터 문자열의 끝("\0")까지 모든 문자를 하나의 문자열로 출력 
printf("%c\n", *p); // p가 가리키는 곳의 문자 출력, *p = *(p+0)
printf("%c\n", *(p+3));
printf("%c\n", *p+2);
// KOREA라는 문자열이 메모리에 저장될 때 문자로 저장되는 것이 아니라
// 해당 문자의 아스키 코드 값이 저장됩니다.
// 즉 K는 K에 해당하는 아스키 코드 값인 75가 저장됩니다.
// *p = 75 + 2 = 77
// 77을 문자로 출력한다는 것은 알파벳 순서 상 K의 다다음 문자인 M 출력

// KOREA
// EA
// K
// E
// M
```
4.
```
#include <stdio.h>
main() {
  struct insa {
    char name[10];
    int age;
  } a[] = { "Kim", 28, "Lee", 38, "Park", 42, "Choi", 31 };
  struct insa *p;
  p = a;
  p++; // 주소에 1을 더하는 것은 다음 자료를 가리키라는 것을 의미하므로 p는 a[1]의 위치를 가리키게 된다.
  printf("%s\n", p->name);
  printf("%d\n", p->age);
}
// Lee
// 38
```

------------

#### JAVA
1.
```
class Connection {
  private static Connection _inst = null; 
  // 객체 변수를 선언만 하게 되면 heap이 아닌 stack 영역에 내용 없이 저장되어 사용이 불가능
  // new가 사용되어야만 heap 영역에 내용이 저장되고 
  // 그 주소도 객체 변수에 전달되면서 사용 가능한 객체 변수가 됩니다.
  private int count = 0;
  public static Connection get() {
    if(__inst == null) {
      _inst = new Connection(); 
      // _inst가 null일 때만 딱 한 번 객체 변수 생성,
      // 객체 변수를 생성한다는 것은
      // 객체 생성 예약어인 new를 통해 heap 영역에 공간을 확보하여
      // Connection 클래스의 내용을 저장한 후 그 주소를 객체 변수에 저장하는 것
      return _inst;
    }
    return _inst;
  }
  public void count() { count++; }
  public int getCount() { return count; }
}

public Test {
  public static void main(String[] args) {
    Connection conn1 = Connection.get(); 
    conn1.count();
    Connection conn2 = Connection.get();
    conn2.count();
    Connection conn3 = Connection.get(); // 주소값을 객체 변수에 저장
    conn3.count(); // 같은 주소 값을 사용하니
    System.out.print(conn1.getCount()); // 1+1+1 = 3이 된다.
  }
}
// 3
```
2.
```
public class Test {
  public static void main(String[] args) {
      int aa[][] = { {45,50,75}, {89} };
      System.out.println(aa[0].length);
      System.out.println(aa[1].length);
      System.out.println(aa[0][0]);
      System.out.println(aa[0][1]);
      System.out.println(aa[1][0]);
  }
} 
// 3
// 1
// 45
// 50
// 89
```
2.
```
public class Test {
  public static void main(String[] args) {
    int j, i;
    for(j=0, i=0; i<=5; i++) {
      j += i;
      System.out.print(i);
      if(i==5) {
        System.out.println("=");
        System.out.println(j); // println과
      } else {
        System.out.print("+"); // print 구분 잘할 것!
      }
    }
  }
}
// 0+1+2+3+4+5=15
```
3.
```
public class Test {
	public static void main(String[] args) {
		System.out.println(Test.check(1));
	}
	( ? ) String check(int num) {
		return (num >= 0) ? "positive" : "negative";
	}
}
// static
// static은 클래스 일므으로 메소드에 접근하기 위해 사용되는 예약어로
// 메소드를 사용하기 위해서는 메소드가 포함된 클래스의 객체 변수를 선언한 후
// [객체변수].[메소드]의 방식으로 접근해야 하지만
// static을 이용하면 객체 변수 없이 [클래스이름].[메소드]의 방식으로 접근하는 것이 가능해집니다.
```
4.
```
class Parent {
	int compute(int num) {
		if(num <= 1) return num;
		return compute(num - 1) + compute(num - 2);
	}
}
class Child extends Parent {
	int compute(int num) {
		if(num <= 1) return num;
		return compute(num - 1) + compute(num - 3);
		// 1) num = 4, compute(3) + compute(1)
		// => (compute(2) + compute(0)) + compute(1)
		// => ((compute(1) + compute(-1)) + compute(0)) + compute(1)
		// => ((1-1)+0)+1 = 1
	}
}

public class Test {
	public static void main(String[] args) {
		Parent obj = new Child(); // 클래스 Child로 형 변환
		System.out.print(obj.compute(4);
		// obj 객체의 자료형이 Parent이므로 Parent.compute()라고 생각할 수 있지만
		// Child로 클래스 형 변환이 발생하였고
		// compute() 메소드가 자식 클래스에서 재정의되었으므로
		// 자식 클래스인 Child의 compute() 메소드가 수행된다.
	}
}
// 1
```


### ＊보안

#### 암호화 알고리즘
- DES
   - 1974년 IBM이 개발하고 1975년 NBS에 의해 미국의 국가 표준으로 발표된 암호화 알고리즘
   - 블록 크기는 64비트, 키 길이는 56비트이며, 16회의 라운드를 수행한다.
   - 컴퓨터 기술이 발달함에 따라 해독이 쉬워지면서 미국의 국가 표준이 2001년 AES로 대체되었다.
- AES
   - 2001년 미국 표준 기술 연구소(NIST)에서 발표한 대칭키 암호화 알고리즘이다.
   - DES의 한계를 느낀 NIST에서 공모한 후 발표하였다.
   - 블록 크기는 128비트이며, 키 길이에 따라서 128, 192, 256으로 분류된다.

#### 데이터베이스 보안 ★★★★★
- 데이터베이스 보안이 추구하는 3대 요소
```
1. 데이터의 보호, 기밀성(Confidentiality)
: 시스템 내의 정보와 자원은 인가된 사용자에게만 접근이 허용되는 것
2. 데이터 위변조 및 파괴 방지, 무결성(Integrity)
: 정당한 방법에 의하지 않고는 데이터가 변경될 수 없음을 의미
3. 데이터에 대한 원활한 접근, 가용성(Availability)
: 인가받은 사용자는 시스템 내의 정보와 자원을 언제라도 사용 가능한 것
```

- 접근 통제 : 데이터가 저장된 객체와 이를 사용하려는 주체 사이의 정보 흐름을 제한하는 것
  - 접근 통제 기술
    - 임의 접근 통제(DAC) ★★★★★
      - 데이터에 접근하는 사용자의 신원에 따라 접근 권한을 부여하여 제어하는 방식으로 데이터의 소유자가 접근통제 권한을 지정하고 제어한다.
      - 객체를 생성한 사용자가 생성된 객체에 대한 모든 권한을 부여받고, 부여된 권한을 다른 사용자에게 허가할 수도 있다.
    - 강제 접근 통제(MAC)
      - 주체와 객체의 등급을 비교하여 접근 권한을 부여하는 방식
      - 시스템이 접근통제 권한을 지정함
      - 데이터베이스 객체별로 보안 등급을 부여할 수 있음
      - 사용자별로 인가 등급을 부여할 수 있음
    - 역할 기반 접근 통제(RBAC)
참고) https://velog.io/@ssook1222/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC-%EC%8B%A4%EA%B8%B0-%EC%8A%A4%ED%84%B0%EB%94%94-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EB%B3%B4%EC%95%88

#### 공격 기법
- ARP 스푸핑 : 로컬 네트워크(LAN)에서 사용하는 ARP 프로토콜의 취약점을 이용한 공격 기법으로, 자신의 물리적 주소(MAC)를 변조하여 다른 PC에 도달해야 하는 데이터 패킷을 가로채거나 방해한다.
- 세션 하이재킹 : '세션을 가로채다'라는 의미로, 정상적인 연결을 RST 패킷을 통해 종료시킨 후, 재연결 시 희생자가 아닌 공격자에게 연결하는 공격 기법
- TCP 세션 하이재킹 : 공격자가 TCP 3-Way Handshake 과정에 끼어듦으로써 서버와 상호 간의 동기화된 시퀀스 번호를 갖고 인가되지 않은 시스템의 기능을 이용하거나 중요한 정보에 접근할 수 있게 된다.
- 스니핑 : 네트워크의 중간에서 남의 패킷 정보를 도청하는 해킹 유형
- 스푸핑 : TCP/IP의 구조적 결함을 이용해 사용자의 시스템 권한을 획득한 뒤 정보를 빼가는 해킹 수법

#### 7. 인증/인가
인증 : 사용자의 신원을 검증하는 행위
- 비밀번호, 일회용 핀, 인증 앱, 생체인식 등
- 문제 예) 소프트웨어 개발에 있어 충족시켜야할 보안 요소 중 패스워드, 인증용 카드, 지문 검사 등의 방법으로 시스템 내의 정보와 자원을 사용하려는 사용자가 합법적인 사용자인지를 확인하는 모든 행위를 가리키는 용어
인가(권한 부여) : 사용자에게 특정 리소스나 기능에 액세스할 수 있는 권한을 부여하는 프로세스
참고) https://www.okta.com/kr/identity-101/authentication-vs-authorization/

### 기타 용어
#### WSDL(Web Services Description Language)
- 웹 서비스와 관련된 서식이나 프로토콜 등을 표준적인 방법으로 기술하고 게시하기 위한 언어로, XML로 작성되며 UDDI의 기초가 된다. SOAP, XML 스키마와 결합하여 인터넷에서 웹 서비스를 제공하기 위해, 클라이언트는 이것을 통해 서버에서 어떠한 조작이 가능한지를 파악할 수 있다.

#### 하둡
- 분산 컴퓨팅
- 오픈 소스 기반 분산 컴퓨팅 플랫폼이다.
- 분산 저장된 데이터들은 클러스터 환경에서 병렬 처리된다.
- 일반 PC급 컴퓨터들로 가상화된 대형 스토리지를 형성하고 그 안에 보관된 거대한 데이터 데이터 세트를 병렬로 처리할 수 있도록 개발되었다.
- 더그 커팅과 마이크 캐퍼렐라가 개발했으며 구글의 맵리듀스(MapReduce) 엔진을 사용하고 있다.
```
하둡은 2006년 야후의 더그 커팅이 '넛치'라는 검색엔진을 개발하는 과정에서
대용량의 비정형 데이터를 기존의 RDB 기술로는 처리가 힘들다는 것을 깨닫고,
새로운 기술을 찾는 중 구글에서 발표한 GFS와 MapReduce 관련 논문을 참고하여 개발하였습니다.
이후 아파치 재단의 오픈 소스로 공개 되었습니다.

하둡은 하나의 성능 좋은 컴퓨터를 이용하여 데이터를 처리하는 대신,
적당한 성능의 범용 컴퓨터 여러 대를 클러스터화하고,
큰 크기의 데이터를 클러스터에서 병렬로 동시에 처리하여
처리 속도를 높이는 것을 목적으로 하는 분산처리를 위한
오픈소스 프레임워크라고 할 수 있습니다.
참고) https://wikidocs.net/22654
```

#### 블록체인
- 피투피(P2P) 네트워크를 이용하여 온라인 금융 거래 정보를 온라인 네트워크 참여자(Peer)의 디지털 장비에 분산 저장하는 기술
참고) https://www.banksalad.com/contents/블록체인-개념-완벽-정리-dh1do

#### 오버로딩 / 오버라이딩(그냥 궁금해서...)
1. 오버로딩
```
// 같은 이름의 메서드(함수)를 여러개 가지면서 매개변수 유형과 개수가 다르도록 하는 것
// https://velog.io/@ohsol/JAVA-%EC%98%A4%EB%B2%84%EB%A1%9C%EB%94%A9%EA%B3%BC-%EC%98%A4%EB%B2%84%EB%9D%BC%EC%9D%B4%EB%94%A9-%EC%B0%A8%EC%9D%B4%EC%99%80-%EC%98%88%EC%A0%9C
class TestOverloading {
  // 매개변수가 없는 sol 메서드
	void sol() {
    	System.out.println("매개변수가 없습니다");
  }
  // 매개변수가 int형 2개인 sol 메서드
	void sol(int a, int b) {
    	System.out.println("매개변수" + a + "와" + b);
  }
  // 매개변수가 String형 1개인 sol 메서드
	void sol(String c) {
    	System.out.println("매개변수" + c);
  }
}

public class TestOverLoad {
	public static void main(String[] args) {
    	TestOverloading ob = new TestOverloading();
        ob.sol();
        ob.sol(1,2);
        ob.sol("오버로딩 테스트");
    }
}
// 이와 같이 sol 메서드가 3개지만, 매개변수 유형과 개수가 다름
// 호출 매개변수에 따라 맞는 함수를 실행함
```
2. 오버라이딩(Overriding)
```
상위 클래스가 가지고 있는 메서드도 하위 클래스로 상속되어 하위 클래스에 사용
하위 클래스에서 메서드를 재정의해서 사용할 수 있음
쉽게 말해 메서드 이름이 같고, 매개변수가 같고, 반환형이 같을 경우 상속받은 메서드를 덮어쓴다고 생각하면 됨
'부모 클래스의 메서드는 무시하고, 자식 클래스의 메서드 기능을 사용하겠다' 와 같음

//부모 클래스
class Woman {
	public String name;
    public int age;
    
    public void info() {
    	System.out.println("여자 이름은 "+name+", 나이는 "+age+"살");
    }
}

// Woman 클래스 상속받은 Job 클래스
class Job extends Woman {
	String job;
    
    // 부모 클래스(Woman)에 있는 info 메서드 재정의
    public void info() {
        System.out.println("여자의 직업은 "+job+"입니다.");
    }
}

public class TestOverRide {
	public static void main(String[] args) {
        
        //Job 객체 생성
        Job job = new Job();
        
        //변수 설정
        job.name = "솔이";
        job.age = 26;
        job.job = "개발자";
        
        //호출
        job.info();
        
    }  
}
```

#### 헝가리안 표기법
- 변수명 작성 시, 변수의 자료형을 알 수 있도록 자료형을 의미하는 문자를 포함하여 작성하는 방법이다.

### 기타 문제
1. 유닉스(Unix)
```
1960년대 AT&T 벨 연구소가 MIT, General Electric 사와 함께 공동 개발한 운영체제이다.
시분할 시스템(Time Sharing System)을 위해 설계된 대화식 운영체제이다.
대부분 C언어로 작성되어 있어 이식성이 높으며 장치, 프로세스 간의 호환성이 높다.
트리 구조의 파일 시스템을 갖는다.
참고) https://gptjs409.github.io/infra/2019/09/23/linux.html
```

2. 프로세스 상태 전이도
![image](https://user-images.githubusercontent.com/24931069/195996514-13dd5914-31d3-47cf-8644-5b6aeae0b264.png)
준비, 실행, 대기

